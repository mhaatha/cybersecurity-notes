CROSS-SITE SCRIPTING (XSS)
XSS is a common web application vulnerability that occurs when a web application returns unsanitized input to the front end of an application. Attacker takes advantages of this vulnerability by inputting malicious code, generally in the form of JavaScript, through the browser.

The 3 categories of XSS attacks are:
- Stored XSS
- Reflected XSS
- DOM-Based XSS

- Stored XSS
Stored XSS attacks are generally considered the most serious. Occurs when a web server saves an attacker's input into its datastores. In a worst-case scenario, this input will be saved, and then returned to numerous victims.
1. Attacker creates comment with code;
2. Server saves the comment;
3. User requests to see comment;
4. Server sends comment to victim;
5. Victim's browser executes code.

- Reflected XSS
Occurs when a user's input is immediately returned back to the user. This return may come in the form of an error message, a popup, or a search term.
1. Attacker sends script-injected link to victim (e.g. email scam);
2. Victim clicks on link and requests legitimate website;
3. Victim's browser loads legitimate site, but also executes malicious script;
4. Malicious script send victim's private data to attacker.

- DOM-Based XSS
DOM (Document Object Model). When user input is interpreted by the DOM, an attacker is able to inject arbitrary code, do not cause any changes in how the server responds. Rather, these attacks are completely client-side.
1. Attacker sends link containing malicious code;
2. Victim opens link;
3. Victim's browser sends request to server;
4. Server responds with page;
5. Victim's browser loads vulnerable Javascript and executes the attacker's payload.

IDENTIFYING XSS VULNERABILITIES
IMPORTANT to investigate any potential input areas. Comments, usernames, custom settings, and parameters all provide greate starting points.

Once we have identified a potential inject point, we can begin testing various inputs to create a proof-of-concept payload (POC). A POC payload will demonstrate that an issue exists, without causing damage. The most basic POC payload is shown below.
<script>alert(1);</script>

Many systems will take a flawed approach to protection and block certain words. If a blocklist is in effect your request may be blocked, or your <script> tags could be removed. In fact, there are numerous ways we can execute code, without ever using a <script> tag. Below are some potential workarounds.
<img src="X" onerror=alert(1);>
<b onmouseover=alert(1)>click me!</b>
<body onload=alert('test1')>

PREVENTING XSS VULNERABILITIES
Similar to SQL injections, XSS is preventable with both application-level firewalls and sanitization. Similar to the SQL injections, firewalls should be used to aid defense, but should not be used as your only line of defense.

- Sanitization
Sanitization is the process of removing/replacing problematic characters with safe versions. We can generally succeed in preventing XSS attacks by removing characters such as <, >, ", =, and potentially dangerous keywords.

We can also replace them with HTML-encoded versions of the characters. This allows us to retain the characters, but remove their capacity of affect the page's HTML.

CROSS-SITE REQUEST FORGERY (CSRF)
-
CSRF is another class of vulnerability focused on poor session controls and session management.

Suppose our web application allows users to change their password via the following link, where [USER PASSWORD] would contain the new desired password.

https://oursite.com/changepassword.php?new_password=\[USER PASSWORD]

If the developers didnâ€™t consider the impact of cross-site request forgery attacks, a threat actor may be able to create a new password link and send it to the user. When the user opens the link, they would initiate the password change, but with the attacker-supplied password! This would allow a hacker to take over their account!

Because the request considers nothing but the current session, a user would have their password changed.

PREVENTING CSRF
CSRF relatively to mitigate. One of the simplest ways to prevent CSRF is to add a CSRF token. This token is a unique value that is added to each request. This value is dynamically generated by the server and used to verify all requests.

CONCLUSION
While cross-site scripting and cross-site request forgery both pose a serious risk to users, and the systems they interact with, developers can take many steps to prevent these attacks. However, when developers fail, attackers can execute arbitrary code, steal information, and cause serious harm. Through careful control of sessions, we can prevent cross-site request forger attacks. And through careful handling of data and sanitization, we can easily prevent cross-site scripting attacks.
